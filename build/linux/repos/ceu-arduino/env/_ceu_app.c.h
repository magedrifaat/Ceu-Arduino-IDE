/*
* This file is automatically generated.
* http://www.ceu-lang.org/
* http://github.com/ceu-lang/ceu/
*
* CÃ©u is distributed under the MIT License:
*

Copyright (C) 2012-2016 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



/* ENV_HEADER */

#include <stdint.h>

typedef void none;

#ifndef __cplusplus
typedef unsigned char bool;
#endif
typedef unsigned char byte;
typedef unsigned int  uint;

//typedef ssize_t  ssize;       // no support in Arduino
typedef size_t   usize;

typedef int8_t    s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

typedef uint8_t   u8;
#ifndef __AVR
typedef uint16_t u16;         // already defined in "USBAPI.h"
#endif
typedef uint32_t u32;
typedef uint64_t u64;

typedef float    real;
typedef float    r32;
typedef double   r64;


/* ENV_CEU */



/* CEU_C */

#define CEU_FEATURES_ISR static
#define CEU_FEATURES_ISR_STATIC
#undef CEU_FEATURES_ASYNC
#undef CEU_FEATURES_LUA
#undef CEU_FEATURES_THREAD
#undef CEU_FEATURES_EXCEPTION
#undef CEU_FEATURES_DYNAMIC
#undef CEU_FEATURES_POOL
#undef CEU_FEATURES_OS
#undef CEU_FEATURES_PAUSE
#undef CEU_FEATURES_TRACE
        /* CEU_FEATURES */

#include <stddef.h>     /* offsetof */
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memset, strlen */
#ifdef CEU_TESTS
#include <stdio.h>
#endif

#ifdef CEU_FEATURES_LUA
#include <lua5.3/lua.h>
#include <lua5.3/lauxlib.h>
#include <lua5.3/lualib.h>
#endif

#define S8_MIN   -127
#define S8_MAX    127
#define U8_MAX    255

#define S16_MIN  -32767
#define S16_MAX   32767
#define U16_MAX   65535

#define S32_MIN  -2147483647
#define S32_MAX   2147483647
#define U32_MAX   4294967295

#define S64_MIN  -9223372036854775807
#define S64_MAX   9223372036854775807
#define U64_MAX   18446744073709551615

typedef u16 tceu_nevt;   /* TODO */
typedef u8  tceu_nstk;   /* TODO */
typedef u8 tceu_ntrl;
typedef u8 tceu_nlbl;

#define CEU_TRAILS_N 7
#ifndef CEU_STACK_N
#define CEU_STACK_N 500
#endif

#define CEU_API
CEU_API void ceu_start (int argc, char* argv[]);
CEU_API void ceu_stop  (void);
CEU_API void ceu_input (tceu_nevt id, void* params);
CEU_API int  ceu_loop  (int argc, char* argv[]);

#ifdef CEU_FEATURES_TRACE
#define CEU_TRACE_null   ((tceu_trace){NULL,NULL,0})

typedef struct tceu_trace {
    struct tceu_trace* up;
    const char* file;
    u32 line;
} tceu_trace;
#endif

struct tceu_code_mem;
struct tceu_pool_pak;

typedef struct tceu_evt {
    tceu_nevt id;
    union {
        void* mem;                   /* CEU_INPUT__PROPAGATE_CODE, CEU_EVENT__MIN */
#ifdef CEU_FEATURES_POOL
        struct tceu_pool_pak* pak;   /* CEU_INPUT__PROPAGATE_POOL */
#endif
    };
} tceu_evt;

typedef struct tceu_range {
    struct tceu_code_mem* mem;
    tceu_ntrl             trl0;
    tceu_ntrl             trlF;
} tceu_range;

typedef struct tceu_stk {
    tceu_evt   evt;
    tceu_range range;
    void*      params;
    usize      params_n;
    bool       is_alive;
    struct tceu_stk* prv;
} tceu_stk;

struct tceu_data_Exception;

typedef struct tceu_trl {
    struct {
        tceu_evt evt;
        union {
            struct {
                tceu_nlbl lbl;
                tceu_nstk level;       /* CEU_INPUT__STACKED */
            };
#ifdef CEU_FEATURES_PAUSE
            struct {
                tceu_evt  pse_evt;
                tceu_ntrl pse_skip;
                u8        pse_paused;
            };
#endif
        };
    };
} tceu_trl;

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_catch {
    struct tceu_catch*         up;
    struct tceu_code_mem*      mem;
    tceu_ntrl                  trl;
    struct tceu_opt_Exception* exception;
} tceu_catch;
#endif

typedef struct tceu_code_mem {
#ifdef CEU_FEATURES_POOL
    struct tceu_pool_pak* pak;
#endif
    struct tceu_code_mem* up_mem;
    u8          depth;
#ifdef CEU_FEATURES_TRACE
    tceu_trace  trace;
#endif
#ifdef CEU_FEATURES_EXCEPTION
    tceu_catch* catches;
#endif
#ifdef CEU_FEATURES_LUA
    lua_State*  lua;
#endif
    bool has_term;
    tceu_ntrl   trails_n;
    tceu_trl    _trails[0];
} tceu_code_mem;

#ifdef CEU_FEATURES_THREAD
typedef struct tceu_threads_data {
    CEU_THREADS_T id;
    u8 has_started:    1;
    u8 has_terminated: 1;
    u8 has_aborted:    1;
    u8 has_notified:   1;
    struct tceu_threads_data* nxt;
} tceu_threads_data;

typedef struct {
    tceu_code_mem*     mem;
    tceu_threads_data* thread;
} tceu_threads_param;
#endif

#ifdef CEU_FEATURES_ISR_STATIC
typedef struct tceu_isr_evt {
    tceu_nevt id;
    u8        len;
    void*     args;
} tceu_isr_evt;
#else
typedef struct tceu_evt_id_params {
    tceu_nevt id;
    void*     params;
} tceu_evt_id_params;
typedef struct tceu_isr {
    void (*fun)(tceu_code_mem*);
    tceu_code_mem*     mem;
    tceu_evt_id_params evt;
} tceu_isr;
#endif

/*****************************************************************************/

/* CEU_VECTOR_H */
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memcpy */

typedef struct {
    usize max;
    usize len;
    usize ini;
    usize unit;
    u8    is_ring:    1;
    u8    is_dyn:     1;
    u8    is_freezed: 1;
    byte* buf;
} tceu_vector;

#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))

#define ceu_vector_idx(vec,idx)     ((vec)->is_ring ? (((vec)->ini + (idx)) % (vec)->max) : (idx))
#define ceu_vector_buf_get(vec,idx) (&(vec)->buf[ceu_vector_idx(vec,idx)*(vec)->unit])
#define ceu_vector_ptr(vec)         (vec)

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu,CEU_TRACE(0))
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n,CEU_TRACE(0))
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,CEU_TRACE(0))
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow,CEU_TRACE(0))
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,CEU_TRACE(0))
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b,CEU_TRACE(0))
#else
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu)
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n)
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,_)
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow)
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,_)
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b)
#endif

void  ceu_vector_init            (tceu_vector* vector, usize max, bool is_ring, bool is_dyn, usize unit, byte* buf);

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c,d)
#else
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c)
#endif

#ifdef CEU_FEATURES_DYNAMIC
byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );
#endif

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c,d)
#else
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c)
#endif

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );


/* CEU_NATIVE_PRE */

#define CEU_ISR(id) ISR(id)

#define CEU_PM_IMPL

    enum {
        CEU_PM_ADC = 0,
        CEU_PM_SPI,
        CEU_PM_TIMER0,
        CEU_PM_TIMER1,
        CEU_PM_TIMER2, // TODO: works in ADC, power-save, ext-standby





        CEU_PM_USART,
        CEU_PM_TWI = 0,
        CEU_PM_N,
    };

# 1 "./libraries/driver-pm/avr/../pm.c" 1




static u32 ceu_pm_state = 0; // TODO: max 32 devices

void ceu_pm_init (void);

void ceu_pm_sleep (void);

int ceu_pm_get (int dev) {
    return bitRead(ceu_pm_state, dev);
}

void ceu_pm_set (u8 dev, bool v) {
    if (v) {
        bitSet(ceu_pm_state, dev);
    } else {
        bitClear(ceu_pm_state, dev);
    }
}
# 22 "./libraries/driver-pm/avr/pm.ceu" 2
#include "LowPower.h"
#include "LowPower.cpp"

    void ceu_pm_init (void) {
    }

    void ceu_pm_sleep (void)
    {
# 45 "./libraries/driver-pm/avr/pm.ceu"
        if (ceu_pm_get(CEU_PM_TIMER0) || ceu_pm_get(CEU_PM_TIMER1) ||
            ceu_pm_get(CEU_PM_TIMER2) || ceu_pm_get(CEU_PM_USART) ||
            ceu_pm_get(CEU_PM_TWI) || ceu_pm_get(CEU_PM_SPI))
        {

            LowPower.idle(SLEEP_FOREVER,
                          (adc_t) ceu_pm_get(CEU_PM_ADC),





                          (timer2_t) ceu_pm_get(CEU_PM_TIMER2),
                          (timer1_t) ceu_pm_get(CEU_PM_TIMER1),
                          (timer0_t) ceu_pm_get(CEU_PM_TIMER0),
                          (spi_t) ceu_pm_get(CEU_PM_SPI),



                          (usart0_t) ceu_pm_get(CEU_PM_USART),
                          (twi_t) ceu_pm_get(CEU_PM_TWI));
        }
        else if (ceu_pm_get(CEU_PM_ADC))
        {
            LowPower.adcNoiseReduction(SLEEP_FOREVER,
                                       (adc_t) ceu_pm_get(CEU_PM_ADC),
                                       TIMER2_OFF);
        }
        else
        {
            LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);
        }


    }

#define __WCLOCK_CEU__
    void ceu_wclock_init (void);
    //void ceu_wclock         (bool v);      // TODO: ???
    void ceu_wclock_request (s32 us, bool was_active);
    void ceu_wclock_done (void);
    s32 ceu_wclock_dt (void);
    u32 ceu_wclock_now (void);

#define USART_BAUD(bps) ((F_CPU/4/bps - 1) / 2)


/* EVENTS_ENUM */

enum {
    /* non-emitable */
    CEU_INPUT__NONE = 0,
    CEU_INPUT__STACKED,
    CEU_INPUT__FINALIZE,
    CEU_INPUT__THROW,
    CEU_INPUT__PAUSE_BLOCK,
    CEU_INPUT__PROPAGATE_CODE,
    CEU_INPUT__PROPAGATE_POOL,

    /* emitable */
    CEU_INPUT__CLEAR,           /* 7 */
    CEU_INPUT__PAUSE,
    CEU_INPUT__RESUME,
    CEU_INPUT__CODE_TERMINATED,
CEU_INPUT__PRIM,
    CEU_INPUT__ASYNC,
    CEU_INPUT__THREAD,
    CEU_INPUT__WCLOCK,

//CEU_INPUT__MIN,
    CEU_INPUT_CEU_WCLOCK,
CEU_INPUT_USART_RX,
CEU_INPUT_USART_TX_DONE,

//CEU_INPUT__MAX,

CEU_EVENT__MIN,
    CEU_EVENT_LOCK_OK_UNLOCKED,

};

enum {
    CEU_OUTPUT__NONE = 0,
    CEU_OUTPUT_OUT,
CEU_OUTPUT_OUT_13,

};

/* CEU_MAIN */


#if 0
#define ceu_callback_log_num(a,b)
#define ceu_callback_log_str(a,b)
#define ceu_callback_log_flush(a)
#define ceu_callback_wclock_min(a,b)
#define ceu_callback_abort(a,b)
#define ceu_callback_terminating(a)
#define ceu_callback_wclock_dt(a) CEU_WCLOCK_INACTIVE
#define ceu_callback_start(a)
#define ceu_callback_stop(a)
#define ceu_callback_step(a)
#define ceu_callback_realloc(a,b,c) NULL
#define ceu_callback_free(a,b)
#endif

//#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"

#ifdef ceu_assert_ex
#define ceu_assert(a,b) ceu_assert_ex(a,b,NONE)
#else
#ifdef CEU_FEATURES_TRACE
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_trace(trace, msg);                                      \
        ceu_callback_abort(0, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg), CEU_TRACE(0))
#else
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_callback_abort(0, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg),NONE)
#endif
#endif

#ifndef ceu_assert_sys
#define ceu_assert_sys(v,msg)   \
    if (!(v)) {                 \
        ceu_callback_log_str(msg, CEU_TRACE_null);  \
        ceu_callback_abort(0, CEU_TRACE_null);      \
    }
#endif

#ifdef CEU_FEATURES_TRACE
static void ceu_trace (tceu_trace trace, const char* msg) {
    static bool IS_FIRST = 1;
    bool is_first = IS_FIRST;

    IS_FIRST = 0;

    if (trace.up != NULL) {
        ceu_trace(*trace.up, msg);
    }

    if (is_first) {
        IS_FIRST = 1;
        ceu_callback_log_str("\n", CEU_TRACE_null);
    }

    ceu_callback_log_str("[",        CEU_TRACE_null);
    ceu_callback_log_str(trace.file, CEU_TRACE_null);
    ceu_callback_log_str(":",        CEU_TRACE_null);
    ceu_callback_log_num(trace.line, CEU_TRACE_null);
    ceu_callback_log_str("]",        CEU_TRACE_null);
    ceu_callback_log_str(" -> ",     CEU_TRACE_null);

    if (is_first) {
        ceu_callback_log_str("runtime error: ", CEU_TRACE_null);
        ceu_callback_log_str(msg,               CEU_TRACE_null);
        ceu_callback_log_str("\n",              CEU_TRACE_null);
        ceu_callback_log_flush(CEU_TRACE_null);
    }
}
#else
#define ceu_trace(a,b)
#endif

#define CEU_ISRS_N 4

/* CEU_ISRS_DEFINES */
#define CEU_ISR__TIMER1_COMPA_vect
#define CEU_ISR__USART_RX_vect
#define CEU_ISR__USART_TX_vect


/* EVENTS_DEFINES */
#define _CEU_OUTPUT_OUT_
#define _CEU_INPUT_CEU_WCLOCK_
#define _CEU_INPUT_USART_RX_
#define _CEU_INPUT_USART_TX_DONE_
#define _CEU_OUTPUT_OUT_13_


/* CEU_DATAS_HIERS */
typedef s16 tceu_ndata;  /* TODO */
enum {
        CEU_DATA_Exception = 0,
};

tceu_ndata CEU_DATA_SUPERS_Exception [] = {
        0,
};
tceu_ndata CEU_DATA_NUMS_Exception [] = {
        CEU_DATA_Exception,
};


static int ceu_data_is (tceu_ndata* supers, tceu_ndata me, tceu_ndata cmp) {
    return (me==cmp || (me!=0 && ceu_data_is(supers,supers[me],cmp)));
}

#ifdef CEU_FEATURES_TRACE
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c,d)
#else
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c)
#endif

__attribute__((__unused__))
static void* ceu_data_as_ (tceu_ndata* supers, tceu_ndata* me, tceu_ndata cmp
#ifdef CEU_FEATURES_TRACE
                         , tceu_trace trace
#endif
                         )
{
    ceu_assert_ex(ceu_data_is(supers, *me, cmp), "invalid cast `as`", trace);
    return me;
}

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a,b)
#else
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a)
#endif

__attribute__((__unused__))
static tceu_evt* CEU_OPTION_EVT_ (tceu_evt* alias
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(alias != NULL, "value is not set", trace);
    return alias;
}

/* CEU_VECTOR_C */
void ceu_vector_init (tceu_vector* vector, usize max, bool is_ring,
                      bool is_dyn, usize unit, byte* buf) {
    vector->len        = 0;
    vector->max        = max;
    vector->ini        = 0;
    vector->unit       = unit;
    vector->is_dyn     = is_dyn;
    vector->is_ring    = is_ring;
    vector->is_freezed = 0;
    vector->buf        = buf;
}

#ifdef CEU_FEATURES_DYNAMIC
byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(vector->is_dyn, "static vector", trace);

    if (vector->max == len) {
        goto END;
    }

    if (len == 0) {
        /* free */
        if (vector->buf != NULL) {
            vector->max = 0;
            ceu_callback_free(vector->buf, trace);
            vector->buf = NULL;
        }
    } else {
        ceu_assert_ex(len > vector->max, "not implemented: shrinking vectors", trace);
        vector->buf = (byte*) ceu_callback_realloc(vector->buf, len*vector->unit, trace);

        if (vector->is_ring && vector->ini>0) {
            /*
             * [X,Y,Z,I,J,K,L,#####,A,B]       -> (grow) ->
             * [X,Y,Z,I,J,K,L,#####,A,B,-,-,-] -> (1st memcpy) ->
             * [?,?,?,I,J,K,L,#####,A,B,X,Y,Z] -> (2nd memmove) ->
             * [I,J,K,L,#####,-,-,-,A,B,X,Y,Z]
             */
            usize dif = len - vector->max;
            usize rig = vector->max - vector->ini;
            if (vector->len > rig) { // if wrap-around then need to shuffle
                usize num = vector->len - rig;
                memcpy(&vector->buf[vector->max * vector->unit], // -,-,-
                       &vector->buf[0],                          // X,Y,Z
                       (num > dif ? dif : num)  * vector->unit); // 3
                if (num > dif) {
                    memmove(&vector->buf[0],                     // X,Y,Z
                            &vector->buf[dif * vector->unit],    // I,J,K,L
                            (num - dif)      * vector->unit);    // rest
                }
            }
        }

        vector->max = len;
    }

    if (freeze) {
        vector->is_freezed = 1;
    }

END:
    return vector->buf;
}
#endif

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        if (len > vector->len) {
            return 0;
        }
    }

    /* fixed size */
#ifdef CEU_FEATURES_DYNAMIC
    if (!vector->is_dyn || vector->is_freezed)
#endif
    {
        if (len > vector->max) {
            return 0;
        }

    /* variable size */
    }
#ifdef CEU_FEATURES_DYNAMIC
    else
    {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                if (len != 0) {
                    return 0;
                }
            }
        }
    }
#endif

    return 1;
}

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        ceu_assert_ex(len <= vector->len, "access out of bounds", trace);
    }

    /* fixed size */
#ifdef CEU_FEATURES_DYNAMIC
    if (!vector->is_dyn || vector->is_freezed)
#endif
    {
        ceu_assert_ex(len <= vector->max, "access out of bounds", trace);

    /* variable size */
    }
#ifdef CEU_FEATURES_DYNAMIC
    else
    {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
/* TODO: shrink memory */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                ceu_assert_ex(len==0, "access out of bounds", trace);
            }
        }
    }
#endif

    if (vector->is_ring && len<vector->len) {
        vector->ini = (vector->ini + (vector->len - len)) % vector->max;
    }

    vector->len = len;
}

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(idx < vector->len, "access out of bounds", trace);
    return ceu_vector_buf_get(vector, idx);
}

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize n = ((nu % vector->unit) == 0) ? nu/vector->unit : nu/vector->unit+1;
#if 0
    if (vector->len < idx+n) {
        char err[50];
        snprintf(err,50, "access out of bounds : length=%ld, index=%ld", vector->len, idx+n);
        ceu_assert_ex(0, err, file, line);
    }
#else
    ceu_assert_ex((vector->len >= idx+n), "access out of bounds", trace);
#endif

    usize k  = (vector->max - ceu_vector_idx(vector,idx));
    usize ku = k * vector->unit;

    if (vector->is_ring && ku<nu) {
        memcpy(ceu_vector_buf_get(vector,idx),   buf,    ku);
        memcpy(ceu_vector_buf_get(vector,idx+k), buf+ku, nu-ku);
    } else {
        memcpy(ceu_vector_buf_get(vector,idx), buf, nu);
    }
}

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize unit = dst->unit;
    ceu_assert_ex((src->unit == dst->unit), "incompatible vectors", trace);

    ceu_assert_ex((src->len >= src_i+n), "access out of bounds", trace);
    ceu_vector_setlen_ex(dst, MAX(dst->len,dst_i+n), 1, trace);

    usize dif_src = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
    usize dif_dst = MIN(n, (dst->max - ceu_vector_idx(dst,dst_i)));
    usize dif = MIN(dif_src, dif_dst);

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);

    dst_i += dif;
    src_i += dif;
    n -= dif;

    if (n == 0) {
        return;
    }

    if (dif_src > dif_dst) {
        dif = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    } else if (dif_dst > dif_src) {
        dif = MIN(n, (dst->max - ceu_vector_idx(dst,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    }

    if (n == 0) {
        return;
    }

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), n);
}


#ifdef CEU_FEATURES_POOL

/* CEU_POOL_C */
#include <stdlib.h>     /* NULL */

typedef struct {
    usize   len;
    usize   free;
    usize   index;
    usize   unit;
    byte*   buf;
    byte**  queue; /* NULL on dynamic pools */
} tceu_pool;

void ceu_pool_init (tceu_pool* pool, usize len, usize unit, byte** queue, byte* buf)
{
    usize i;
    pool->len   = len;
    pool->free  = len;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->buf   = buf;
    for (i=0; i<len; i++) {
        queue[i] = &buf[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->len) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    usize empty = pool->index + pool->free;
    if (empty >= pool->len) {
        empty -= pool->len;
    }
    pool->queue[empty] = val;
    pool->free++;
}


typedef struct tceu_code_mem_dyn {
    struct tceu_code_mem_dyn* prv;
    struct tceu_code_mem_dyn* nxt;
    u8 is_alive: 1;
    tceu_code_mem mem[0];   /* actual tceu_code_mem is in sequence */
} tceu_code_mem_dyn;

typedef struct tceu_pool_pak {
    tceu_pool         pool;
    tceu_code_mem_dyn first;
    tceu_code_mem*    up_mem;
    u8                n_traversing;
} tceu_pool_pak;

#endif

/* CEU_DATAS_MEMS */

#pragma pack(push,1)
typedef struct tceu_data_Lock {
    #line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
bool  is_locked;
#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
} tceu_data_Lock;

typedef struct tceu_data_Exception {
    tceu_ndata _enum;
    #line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
char*  message;
} tceu_data_Exception;



#pragma pack(pop)

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_opt_Exception {
    bool      is_set;
    tceu_data_Exception value;
} tceu_opt_Exception;

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a,b)
#else
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a)
#endif

static tceu_opt_Exception* CEU_OPTION_tceu_opt_Exception_ (tceu_opt_Exception* opt
#ifdef CEU_FEATURES_TRACE
                                                          , tceu_trace trace
#endif
                                                          )
{
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}
#endif

/*****************************************************************************/

typedef struct tceu_output_OUT {
    int _1;
    bool _2;
} tceu_output_OUT;
typedef struct tceu_output_mem_OUT {
    struct {
#line 8 "./libraries/driver-gpio/out.ceu"
int  pin;
#line 8 "./libraries/driver-gpio/out.ceu"
bool  v;
union {
struct {
union {
};
};
};
};
} tceu_output_mem_OUT;
typedef struct tceu_input_CEU_WCLOCK {
} tceu_input_CEU_WCLOCK;
typedef struct tceu_input_USART_RX {
} tceu_input_USART_RX;
typedef struct tceu_input_USART_TX_DONE {
} tceu_input_USART_TX_DONE;
typedef struct tceu_output_OUT_13 {
    bool _1;
} tceu_output_OUT_13;

typedef struct tceu_event___lpar____rpar__ {
} tceu_event___lpar____rpar__;

typedef struct tceu_code_mem_WCLOCK_Now {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
u32  _ret;
union {
struct {
union {
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_WCLOCK_Now;
typedef struct tceu_code_mem_WCLOCK_Freeze {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
u32  us;
union {
union {
};
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_WCLOCK_Freeze;
typedef struct tceu_code_mem_USART_Init {
    tceu_code_mem _mem;
    tceu_trl      _trails[5];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
struct {
#line 66 "./libraries/driver-usart/avr/usart.ceu"
int  bps;
union {
union {
};
struct {
union {
struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
};
};
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_USART_Init;
typedef struct tceu_code_mem_ROOT {
    tceu_code_mem _mem;
    tceu_trl      _trails[7];
    byte          _params[0];
    struct {
#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
int  _RET;
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 5 "./libraries/driver-gpio/out.ceu"
#line 8 "./libraries/driver-gpio/out.ceu"
#line 14 "./libraries/driver-wclock/avr/timer1-compa.ceu"
#line 67 "./libraries/driver-wclock/avr/../wclock.ceu"
#line 30 "./libraries/driver-usart/avr/usart.ceu"
#line 32 "./libraries/driver-usart/avr/usart.ceu"
#line 33 "./libraries/driver-usart/avr/usart.ceu"
#line 35 "./libraries/driver-usart/avr/usart.ceu"
#line 35 "./libraries/driver-usart/avr/usart.ceu"
#line 36 "./libraries/driver-usart/avr/usart.ceu"
#line 36 "./libraries/driver-usart/avr/usart.ceu"
#line 9 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
union {
struct {
#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
#line 5 "./libraries/driver-usart/avr/../usart.ceu"
#line 6 "./libraries/driver-usart/avr/../usart.ceu"
#line 7 "./libraries/driver-usart/avr/../usart.ceu"
#line 17 "./libraries/driver-usart/avr/usart.ceu"
tceu_data_Lock  usart_lock;
#line 18 "./libraries/driver-usart/avr/usart.ceu"
u8  usart_pm_refs;
#line 20 "./libraries/driver-usart/avr/usart.ceu"
byte usart_rx_buf_110_buf[32];
tceu_vector usart_rx_buf_110;
#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
byte str_346_buf[20];
tceu_vector str_346;
#line 10 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
int  i;
union {
struct {
union {
tceu_code_mem_USART_Init __mem_335;
};
union {
struct {
struct {
union {
struct {
union {
struct {
struct {
union {
struct {
struct {
union {
s32 __wclk_359;
};
};
struct {
union {
struct {
struct {
union {
s32 __wclk_369;
s32 __wclk_378;
};
};
};
};
};
};
};
};
int __fr_950;
int __lim_950;
};
};
};
struct {
union {
struct {
struct {
union {
struct {
struct {
union {
s32 __wclk_394;
};
};
struct {
union {
struct {
struct {
union {
s32 __wclk_404;
s32 __wclk_415;
};
};
};
};
};
};
};
};
int __fr_958;
int __lim_958;
};
};
};
};
};
};
};
};
};
};
};
};
} tceu_code_mem_ROOT;



enum {
    CEU_LABEL_NONE = 0,
    CEU_LABEL_ROOT,
CEU_LABEL_Block__CLR_2,
CEU_LABEL_Block__CLR_3,
CEU_LABEL_Block__CLR_4,
CEU_LABEL_Do__OUT_5,
CEU_LABEL_Do__CLR_6,
CEU_LABEL_Block__CLR_7,
CEU_LABEL_WCLOCK_Now_Block__CLR_8,
CEU_LABEL_WCLOCK_Now_Block__CLR_9,
CEU_LABEL_WCLOCK_Now_Block__CLR_10,
CEU_LABEL_WCLOCK_Now_Do__OUT_11,
CEU_LABEL_WCLOCK_Now_Do__CLR_12,
CEU_LABEL_WCLOCK_Now_Block__CLR_13,
CEU_LABEL_Code_WCLOCK_Now,
CEU_LABEL_WCLOCK_Now_Code_WCLOCK_Now__TERM_15,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_16,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_17,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_18,
CEU_LABEL_WCLOCK_Freeze_Do__OUT_19,
CEU_LABEL_WCLOCK_Freeze_Do__CLR_20,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_21,
CEU_LABEL_Code_WCLOCK_Freeze,
CEU_LABEL_WCLOCK_Freeze_Code_WCLOCK_Freeze__TERM_23,
CEU_LABEL_Block__CLR_24,
CEU_LABEL_Async_Isr__FIN_25,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_26,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_27,
CEU_LABEL_USART_Init_Par_Or__OUT_28,
CEU_LABEL_USART_Init_Par_Or__CLR_29,
CEU_LABEL_USART_Init_Block__CLR_30,
CEU_LABEL_USART_Init_Finalize_Case__IN_31,
CEU_LABEL_USART_Init_Block__CLR_32,
CEU_LABEL_USART_Init_Block__CLR_33,
CEU_LABEL_USART_Init_Do__OUT_34,
CEU_LABEL_USART_Init_Do__CLR_35,
CEU_LABEL_USART_Init_Block__CLR_36,
CEU_LABEL_Code_USART_Init,
CEU_LABEL_USART_Init_Code_USART_Init__TERM_38,
CEU_LABEL_Block__CLR_39,
CEU_LABEL_Async_Isr__FIN_40,
CEU_LABEL_Block__CLR_41,
CEU_LABEL_Block__CLR_42,
CEU_LABEL_Block__CLR_43,
CEU_LABEL_Async_Isr__FIN_44,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_45,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_46,
CEU_LABEL_USART_Init_Par_Or__OUT_47,
CEU_LABEL_USART_Init_Par_Or__CLR_48,
CEU_LABEL_USART_Init_Block__CLR_49,
CEU_LABEL_USART_Init_Finalize_Case__IN_50,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_51,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_52,
CEU_LABEL_USART_Init_Par_Or__OUT_53,
CEU_LABEL_USART_Init_Par_Or__CLR_54,
CEU_LABEL_USART_Init_Block__CLR_55,
CEU_LABEL_USART_Init_Finalize_Case__IN_56,
CEU_LABEL_USART_Init_Block__CLR_57,
CEU_LABEL_USART_Init_Block__CLR_58,
CEU_LABEL_USART_Init_Block__CLR_59,
CEU_LABEL_USART_Init_Do__OUT_60,
CEU_LABEL_USART_Init_Do__CLR_61,
CEU_LABEL_USART_Init_Block__CLR_62,
CEU_LABEL_USART_Init_Code_USART_Init__TERM_63,
CEU_LABEL_Par_Or_sub_1_IN_64,
CEU_LABEL_Par_Or_sub_2_IN_65,
CEU_LABEL_Par_Or__OUT_66,
CEU_LABEL_Par_Or__CLR_67,
CEU_LABEL_Await_Spawn__OUT_68,
CEU_LABEL_Par_Or_sub_1_IN_69,
CEU_LABEL_Par_Or_sub_2_IN_70,
CEU_LABEL_Par_Or__OUT_71,
CEU_LABEL_Par_Or__CLR_72,
CEU_LABEL_Await_Wclock__OUT_73,
CEU_LABEL_Block__CLR_74,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_75,
CEU_LABEL_Await_Wclock__OUT_76,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_77,
CEU_LABEL_Await_Wclock__OUT_78,
CEU_LABEL_Block__CLR_79,
CEU_LABEL_Loop__CLR_80,
CEU_LABEL_Loop_Continue__CNT_81,
CEU_LABEL_Loop_Continue__CLR_82,
CEU_LABEL_Loop_Break__OUT_83,
CEU_LABEL_Block__CLR_84,
CEU_LABEL_Block__CLR_85,
CEU_LABEL_Loop__CLR_86,
CEU_LABEL_Loop_Continue__CNT_87,
CEU_LABEL_Loop_Continue__CLR_88,
CEU_LABEL_Loop_Break__OUT_89,
CEU_LABEL_Block__CLR_90,
CEU_LABEL_Par_Or_sub_1_IN_91,
CEU_LABEL_Par_Or_sub_2_IN_92,
CEU_LABEL_Par_Or__OUT_93,
CEU_LABEL_Par_Or__CLR_94,
CEU_LABEL_Await_Wclock__OUT_95,
CEU_LABEL_Block__CLR_96,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_97,
CEU_LABEL_Await_Wclock__OUT_98,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_99,
CEU_LABEL_Await_Wclock__OUT_100,
CEU_LABEL_Block__CLR_101,
CEU_LABEL_Loop__CLR_102,
CEU_LABEL_Loop_Continue__CNT_103,
CEU_LABEL_Loop_Continue__CLR_104,
CEU_LABEL_Loop_Break__OUT_105,
CEU_LABEL_Block__CLR_106,
CEU_LABEL_Block__CLR_107,
CEU_LABEL_Loop__CLR_108,
CEU_LABEL_Loop_Continue__CNT_109,
CEU_LABEL_Loop_Continue__CLR_110,
CEU_LABEL_Loop_Break__OUT_111,
CEU_LABEL_Block__CLR_112,
CEU_LABEL_Block__CLR_113,
CEU_LABEL_Loop__CLR_114,
CEU_LABEL_Loop_Continue__CNT_115,
CEU_LABEL_Loop_Continue__CLR_116,
CEU_LABEL_Loop_Break__OUT_117,
CEU_LABEL_Block__CLR_118,
CEU_LABEL_Do__OUT_119,
CEU_LABEL_Do__CLR_120,
CEU_LABEL_Block__CLR_121,

};

/*****************************************************************************/

typedef struct tceu_app {
#ifdef CEU_FEATURES_OS
    int    argc;
    char** argv;

    bool end_ok;
    int  end_val;
#endif

    /* ASYNC */
#ifdef CEU_FEATURES_ASYNC
    bool async_pending;
#endif

    /* WCLOCK */
    s32 wclk_late;
    s32 wclk_min_set;
    s32 wclk_min_cmp;

#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_T threads_mutex;
    tceu_threads_data*  threads_head;   /* linked list of threads alive */
    tceu_threads_data** cur_;           /* TODO: HACK_6 "gc" mutable iterator */
#endif

    byte  stack[CEU_STACK_N];
    usize stack_i;

    tceu_code_mem_ROOT root;
} tceu_app;

CEU_API static tceu_app CEU_APP;

/*****************************************************************************/

__attribute__((__unused__))
static tceu_code_mem* ceu_outer (tceu_code_mem* mem, u8 n) {
    for (; mem->depth!=n; mem=mem->up_mem);
    return mem;
}

/*****************************************************************************/

#define CEU_WCLOCK_INACTIVE INT32_MAX

#ifdef CEU_FEATURES_TRACE
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c,d)
#else
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c)
#endif

__attribute__((__unused__))
static int ceu_wclock_ (s32 dt, s32* set, s32* sub
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
                      )
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "sub") */

    /* SET */
    if (set != NULL) {
        t = dt - CEU_APP.wclk_late;
        *set = t;

    /* SUB */
    } else {
        t = *sub;
        if ((t > CEU_APP.wclk_min_cmp) || (t > dt)) {
            *sub -= dt;    /* don't expire yet */
            t = *sub;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (CEU_APP.wclk_min_set > t) ) {
        CEU_APP.wclk_min_set = t;
        ceu_callback_wclock_min(t, CEU_TRACE_null);
    }

    return ret;
}

__attribute__((__unused__))
static void ceu_params_cpy (tceu_stk* stk, void* params, usize params_n) {
    ceu_assert_sys(CEU_APP.stack_i+params_n < CEU_STACK_N, "stack overflow");
    memcpy(&CEU_APP.stack[CEU_APP.stack_i], params, params_n);
    stk->params   = &CEU_APP.stack[CEU_APP.stack_i];
    stk->params_n = params_n;
    CEU_APP.stack_i += stk->params_n;
}

/*****************************************************************************/

static void ceu_stack_clear (tceu_stk* cur, tceu_code_mem* mem) {
    if (cur == NULL) {
        return;
    }
    if (cur->range.mem == mem) {
        cur->is_alive = 0;
    }
    ceu_stack_clear(cur->prv, mem);
}

#ifdef CEU_FEATURES_POOL
static void ceu_code_mem_dyn_free (tceu_pool* pool, tceu_code_mem_dyn* cur) {
    cur->nxt->prv = cur->prv;
    cur->prv->nxt = cur->nxt;

#ifdef CEU_FEATURES_DYNAMIC
    if (pool->queue == NULL) {
        /* dynamic pool */
        ceu_callback_free(cur, CEU_TRACE_null);
    } else
#endif
    {
        /* static pool */
        ceu_pool_free(pool, (byte*)cur);
    }
}

static void ceu_code_mem_dyn_gc (tceu_pool_pak* pak) {
    if (pak->n_traversing == 0) {
        /* TODO-OPT: one element killing another is unlikely:
                     set bit in pool when this happens and only
                     traverses in this case */
        tceu_code_mem_dyn* cur = pak->first.nxt;
        while (cur != &pak->first) {
            tceu_code_mem_dyn* nxt = cur->nxt;
            if (!cur->is_alive) {
                ceu_code_mem_dyn_free(&pak->pool, cur);
            }
            cur = nxt;
        }
    }
}
#endif

/*****************************************************************************/

#ifdef CEU_FEATURES_LUA
static void ceu_lua_createargtable (lua_State* lua, char** argv, int argc, int script) {
    int i, narg;
    if (script == argc) script = 0;  /* no script name? */
    narg = argc - (script + 1);  /* number of positive indices */
    lua_createtable(lua, narg, script + 1);
    for (i = 0; i < argc; i++) {
        lua_pushstring(lua, argv[i]);
        lua_rawseti(lua, -2, i - script);
    }
    lua_setglobal(lua, "arg");
}

#endif

/*****************************************************************************/

static int ceu_lbl (tceu_nstk _ceu_level, tceu_stk* _ceu_cur, tceu_stk* _ceu_nxt, tceu_code_mem* _ceu_mem, tceu_nlbl _ceu_lbl, tceu_ntrl* _ceu_trlK);


#define ceu_callback_output_OUT_00(ps,trace) digitalWrite( 0, *((bool*)ps))
#define ceu_callback_output_OUT_01(ps,trace) digitalWrite( 1, *((bool*)ps))
#define ceu_callback_output_OUT_02(ps,trace) digitalWrite( 2, *((bool*)ps))
#define ceu_callback_output_OUT_03(ps,trace) digitalWrite( 3, *((bool*)ps))
#define ceu_callback_output_OUT_04(ps,trace) digitalWrite( 4, *((bool*)ps))
#define ceu_callback_output_OUT_05(ps,trace) digitalWrite( 5, *((bool*)ps))
#define ceu_callback_output_OUT_06(ps,trace) digitalWrite( 6, *((bool*)ps))
#define ceu_callback_output_OUT_07(ps,trace) digitalWrite( 7, *((bool*)ps))
#define ceu_callback_output_OUT_08(ps,trace) digitalWrite( 8, *((bool*)ps))
#define ceu_callback_output_OUT_09(ps,trace) digitalWrite( 9, *((bool*)ps))
#define ceu_callback_output_OUT_10(ps,trace) digitalWrite(10, *((bool*)ps))
#define ceu_callback_output_OUT_11(ps,trace) digitalWrite(11, *((bool*)ps))
#define ceu_callback_output_OUT_12(ps,trace) digitalWrite(12, *((bool*)ps))
#define ceu_callback_output_OUT_13(ps,trace) digitalWrite(13, *((bool*)ps))

    static bool ceu_wclock_is_active = 0;

    void ceu_arduino_callback_wclock_min (s32 dt) {
        ceu_wclock_request(dt, ceu_wclock_is_active);
        ceu_wclock_is_active = (dt != CEU_WCLOCK_INACTIVE);
        ceu_pm_set(CEU_PM_TIMER1, ceu_wclock_is_active);
    }

    s32 ceu_arduino_callback_wclock_dt (void) {
        return (ceu_wclock_is_active) ? ceu_wclock_dt() : CEU_WCLOCK_INACTIVE;
    }

    static u16 ceu_timer1_old;

    void ceu_wclock_init (void) {
        ceu_timer1_old = TCNT1;
        TCCR1A = 0;







        TCCR1B = 0b101;



    }

    void ceu_wclock_request (s32 us, bool was_active) {
        if (us == CEU_WCLOCK_INACTIVE) {
            bitClear(TIMSK1, OCIE1A);
        } else {
            s32 v = ((s32)(((double)(us))*F_CPU/1024/1000000L));
            ceu_assert(v < U16_MAX, "bug found");
            OCR1A = (ceu_timer1_old + v);
            bitSet(TIMSK1, OCIE1A);
        }
    }

    void ceu_wclock_done (void) {
        // ok
    }

    s32 ceu_wclock_dt (void) {
        u16 now = TCNT1;
        //ceu_assert(now<128, "bug found");     (not really, only if called due to CEU_WCLOCK)
        s32 dt = (u16)(now - ceu_timer1_old);
        ceu_timer1_old = now;
        return ((s32)(((double)(dt))*1000000L*1024/F_CPU)+1);
    }

    u32 ceu_wclock_now (void) {
        return ((s32)(((double)(TCNT1))*1000000L*1024/F_CPU)+1);
    }

    tceu_vector* usart_tx_buf;
    usize usart_tx_buf_i;


static u32 /* space */
CEU_CODE_WCLOCK_Now (tceu_code_mem_WCLOCK_Now mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_WCLOCK_Now* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_WCLOCK_Now;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}
static none /* space */
CEU_CODE_WCLOCK_Freeze (tceu_code_mem_WCLOCK_Freeze mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_WCLOCK_Freeze* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_WCLOCK_Freeze;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static tceu_nlbl CEU_CODE_USART_Init_to_lbl (tceu_code_mem_USART_Init* mem)
{
    tceu_nlbl lbl = CEU_LABEL_Code_USART_Init;
    return lbl;
}


#ifdef CEU_FEATURES_TRACE
#define ceu_callback_output_OUT(a,b) ceu_callback_output_OUT_(a,b)
#else
#define ceu_callback_output_OUT(a,b) ceu_callback_output_OUT_(a)
#endif
int ceu_callback_output_OUT_ (tceu_output_OUT* ps
#ifdef CEU_FEATURES_TRACE
                                                                  , tceu_trace trace
#endif
                                                                  )
{
#define CEU_TRACE(n) trace
    tceu_output_mem_OUT _ceu_loc;

/* Block (n=23, ln=9) */

#line 9 "./libraries/driver-gpio/out.ceu"
{

/* Stmt_Call (n=21, ln=9) */

#line 9 "./libraries/driver-gpio/out.ceu"
digitalWrite((((*ps)._1)),(((*ps)._2)));

/* Block (n=23, ln=9) */

#line 9 "./libraries/driver-gpio/out.ceu"
}

/* Do (n=702, ln=8) */

#line 8 "./libraries/driver-gpio/out.ceu"
CEU_LABEL_Do__OUT_5:;
#undef CEU_TRACE
return 0;
}


typedef struct tceu_isr_mem_71 {
    struct {
union {
};
};
} tceu_isr_mem_71;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(TIMER1_COMPA_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_71 _ceu_loc;
    
/* Block (n=70, ln=69) */

#line 69 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Nat_Stmt (n=65, ln=69) */

#line 69 "./libraries/driver-wclock/avr/../wclock.ceu"
ceu_wclock_done();
/* Emit_Ext_emit (n=68, ln=70) */

#line 70 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Emit_Ext_emit (n=68, ln=70) */

#line 70 "./libraries/driver-wclock/avr/../wclock.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_CEU_WCLOCK,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(1, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_CEU_WCLOCK,{NULL}}).id, NULL };
    ceu_callback_isr_emit(TIMER1_COMPA_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=68, ln=70) */

#line 70 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=70, ln=69) */

#line 69 "./libraries/driver-wclock/avr/../wclock.ceu"
}
}
typedef struct tceu_isr_mem_141 {
    struct {
union {
};
};
} tceu_isr_mem_141;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(USART_RX_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_141 _ceu_loc;
    
/* Block (n=140, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
{

/* Set_Vec (n=134, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=134, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
    __ceu_nxt = ((CEU_APP.root.usart_rx_buf_110)).len;

/* Set_Vec (n=134, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
    __ceu_nxt = ((CEU_APP.root.usart_rx_buf_110)).len;

/* Set_Vec (n=134, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
    ceu_vector_setlen(&((CEU_APP.root.usart_rx_buf_110)), (((CEU_APP.root.usart_rx_buf_110)).len + 1), 1);

/* Set_Vec (n=134, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
    *((byte*)
        ceu_vector_buf_get(&((CEU_APP.root.usart_rx_buf_110)), __ceu_nxt++)) = UDR0;

/* Set_Vec (n=134, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"

/* Set_Vec (n=134, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
}

/* Emit_Ext_emit (n=138, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
{

/* Emit_Ext_emit (n=138, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_RX,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(2, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_RX,{NULL}}).id, NULL };
    ceu_callback_isr_emit(USART_RX_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=138, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=140, ln=44) */

#line 44 "./libraries/driver-usart/avr/usart.ceu"
}
}
typedef struct tceu_isr_mem_160 {
    struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
} tceu_isr_mem_160;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(USART_TX_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_160 _ceu_loc;
    
/* Block (n=159, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
{

/* If (n=157, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
if (((usart_tx_buf_i)<(usart_tx_buf->len))) {
    
/* Block (n=151, ln=55) */

#line 55 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=148, ln=55) */

#line 55 "./libraries/driver-usart/avr/usart.ceu"
 UDR0 = *(byte*)(ceu_vector_geti(usart_tx_buf,usart_tx_buf_i)); 
/* Nat_Stmt (n=149, ln=56) */

#line 56 "./libraries/driver-usart/avr/usart.ceu"
 usart_tx_buf_i++; 
/* Block (n=151, ln=55) */

#line 55 "./libraries/driver-usart/avr/usart.ceu"
}
} else {
    
/* Block (n=156, ln=58) */

#line 58 "./libraries/driver-usart/avr/usart.ceu"
{

/* Emit_Ext_emit (n=154, ln=58) */

#line 58 "./libraries/driver-usart/avr/usart.ceu"
{

/* Emit_Ext_emit (n=154, ln=58) */

#line 58 "./libraries/driver-usart/avr/usart.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_TX_DONE,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(3, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_TX_DONE,{NULL}}).id, NULL };
    ceu_callback_isr_emit(USART_TX_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=154, ln=58) */

#line 58 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=156, ln=58) */

#line 58 "./libraries/driver-usart/avr/usart.ceu"
}
}

/* Block (n=159, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
}
}




/*****************************************************************************/

#ifdef CEU_FEATURES_EXCEPTION
static int ceu_throw_ex (tceu_catch* catches, tceu_data_Exception* exception, usize len
                  , tceu_nstk level, tceu_stk* nxt
#ifdef CEU_FEATURES_TRACE
                  , tceu_trace trace
#endif
                  )
{
    tceu_catch* cur = catches;
    while (cur != NULL) {
        if (ceu_data_is(CEU_DATA_SUPERS_Exception,exception->_enum,cur->exception->value._enum)) {
            //ceu_sys_assert(!cur->exception->is_set, "double catch");
            ceu_assert_ex(!cur->exception->is_set, "double catch", trace);
            cur->exception->is_set = 1;
            memcpy(&cur->exception->value, exception, len);

#if 0
            /* do not allow nested catches (and itself) to awake */
            cur->exception = NULL;
            while (catches != cur) {
                catches->exception = NULL;
                catches = catches->up;
            }
#endif

            //return ceu_lbl(NULL, stk, cur->mem, cur->trl, cur->mem->_trails[cur->trl].lbl);
            //return ceu_lbl(_ceu_level, _ceu_cur, _ceu_nxt, _ceu_mem, _ceu_lbl, _ceu_trlK)
            cur->mem->_trails[cur->trl].evt.id = CEU_INPUT__STACKED;
            cur->mem->_trails[cur->trl].level = level + 1;
//printf(">>> %d %d\n", cur->trl, cur->mem->_trails[cur->trl].lbl);
            tceu_evt   evt   = {CEU_INPUT__NONE, {NULL}};
            //tceu_range range = { cur->mem, cur->trl, cur->trl };
            tceu_range range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
            nxt->evt      = evt;
            nxt->range    = range;
            nxt->params_n = 0;
            return 1;
        }
        cur = cur->up;
    }
    ceu_assert_ex(0, exception->message, trace);
    return 0;
}
#ifdef CEU_FEATURES_TRACE
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_level,_ceu_nxt,CEU_TRACE(0))
#else
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_level,_ceu_nxt)
#endif
#endif

#ifdef CEU_FEATURES_THREAD
static int ceu_threads_gc (int force_join) {
    int n_alive = 0;
    CEU_APP.cur_ = &CEU_APP.threads_head;
    tceu_threads_data*  head  = *CEU_APP.cur_;
    while (head != NULL) {
        tceu_threads_data** nxt_ = &head->nxt;
        if (head->has_terminated || head->has_aborted)
        {
            if (!head->has_notified) {
                ceu_input(CEU_INPUT__THREAD, &head->id);
                head->has_notified = 1;
            }

            /* remove from list if rejoined */
            {
                int has_joined;
                if (force_join || head->has_terminated) {
                    CEU_THREADS_JOIN(head->id);
                    has_joined = 1;
                } else {
                    /* possible with "CANCEL" which prevents setting "has_terminated" */
                    has_joined = CEU_THREADS_JOIN_TRY(head->id);
                }
                if (has_joined) {
                    *CEU_APP.cur_ = head->nxt;
                    nxt_ = CEU_APP.cur_;
                    ceu_callback_free(head, CEU_TRACE_null);
                }
            }
        }
        else
        {
            n_alive++;
        }
        CEU_APP.cur_ = nxt_;
        head  = *CEU_APP.cur_;
    }
    return n_alive;
}
#endif

/*****************************************************************************/

#define CEU_GOTO(lbl) {_ceu_lbl=lbl; goto _CEU_LBL_;}

static int ceu_lbl (tceu_nstk _ceu_level, tceu_stk* _ceu_cur, tceu_stk* _ceu_nxt, tceu_code_mem* _ceu_mem, tceu_nlbl _ceu_lbl, tceu_ntrl* _ceu_trlK)
{
#define CEU_TRACE(n) ((tceu_trace){&_ceu_mem->trace,__FILE__,__LINE__+(n)})
#ifdef CEU_STACK_MAX
    {
        static void* base = NULL;
        if (base == NULL) {
            base = &_ceu_level;
        } else {
#if 0
#if 0
//Serial.begin(9600);
Serial.println((usize)base);
Serial.println((usize)&_ceu_lbl);
Serial.print(" lbl "); Serial.println(_ceu_lbl);
//Serial.flush();
    if((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_level)) {
    } else {
        delay(1000);
    }
#else
printf(">>> %p / %p / %ld\n", base, &_ceu_lbl, ((u64)base)-((u64)&_ceu_lbl));
printf("%ld %ld %d\n", (usize)(base-CEU_STACK_MAX), (usize)(&_ceu_level),
            ((usize)(base-CEU_STACK_MAX) <= (usize)(&_ceu_level)));
#endif
#endif
            ceu_assert((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_level), "stack overflow");
        }
    }
#endif

_CEU_LBL_:
    //printf("-=-=- %d -=-=-\n", _ceu_lbl);
    switch (_ceu_lbl) {
        case CEU_LABEL_NONE:
            break;
        
/* ROOT (n=472, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_ROOT:;

/* Block (n=471, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Block (n=466, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Nat_Stmt (n=27, ln=50) */

#line 50 "./libraries/driver-gpio/out.ceu"

#ifdef _CEU_OUTPUT_OUT_00_
    pinMode( 0, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_01_
    pinMode( 1, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_02_
    pinMode( 2, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_03_
    pinMode( 3, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_04_
    pinMode( 4, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_05_
    pinMode( 5, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_06_
    pinMode( 6, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_07_
    pinMode( 7, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_08_
    pinMode( 8, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_09_
    pinMode( 9, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_10_
    pinMode(10, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_11_
    pinMode(11, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_12_
    pinMode(12, OUTPUT);
#endif
#ifdef _CEU_OUTPUT_OUT_13_
    pinMode(13, OUTPUT);
#endif

/* Code (n=724, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=724, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_Code_WCLOCK_Now:;

/* Block (n=723, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=715, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=713, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=36, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Set_Exp (n=725, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
(((*((tceu_code_mem_WCLOCK_Now*)_ceu_mem))._ret)) = ( ceu_wclock_now() );

/* Escape (n=34, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
CEU_GOTO(CEU_LABEL_WCLOCK_Now_Do__OUT_11);

/* Block (n=36, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=713, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=715, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Do (n=716, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=716, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_WCLOCK_Now_Do__OUT_11:;

/* Block (n=723, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Code (n=724, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
return 0;

/* Code (n=724, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Code (n=738, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=738, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_Code_WCLOCK_Freeze:;

/* Block (n=737, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=733, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=731, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=52, ln=12) */

#line 12 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Stmt_Call (n=50, ln=12) */

#line 12 "./libraries/driver-wclock/avr/../wclock.ceu"
delayMicroseconds((((*((tceu_code_mem_WCLOCK_Freeze*)_ceu_mem)).us)));

/* Block (n=52, ln=12) */

#line 12 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=731, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=733, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Do (n=734, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_WCLOCK_Freeze_Do__OUT_19:;

/* Block (n=737, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Code (n=738, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
return 0;

/* Code (n=738, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Nat_Stmt (n=57, ln=59) */

#line 59 "./libraries/driver-wclock/avr/../wclock.ceu"

    ceu_wclock_init();

/* Set_Exp (n=973, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
((((CEU_APP.root.usart_lock)).is_locked)) = 0;

/* Set_Exp (n=105, ln=18) */

#line 18 "./libraries/driver-usart/avr/usart.ceu"
((CEU_APP.root.usart_pm_refs)) = 0;

/* Vec_Init (n=989, ln=20) */

#line 20 "./libraries/driver-usart/avr/usart.ceu"
ceu_vector_init(&((CEU_APP.root.usart_rx_buf_110)),32, 1, 0, sizeof(byte),
                (byte*)&((CEU_APP.root.usart_rx_buf_110_buf)));

/* Code (n=846, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=846, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_Code_USART_Init:;

/* Block (n=845, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
{

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Init_Par_Or_sub_2_IN_46;

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or_sub_1_IN_45);

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_1_IN_45:;

/* Finalize_Case (n=1105, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Init_Finalize_Case__IN_50;

/* Finalize_Case (n=1105, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=1105, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Finalize_Case__IN_50:;

/* Block (n=840, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
{

/* Code_Finalize (n=838, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
if (_ceu_mem->has_term) {
    /* generate only if terminating from inside */
    _ceu_mem->_trails[1].evt.id = CEU_INPUT__STACKED;
    _ceu_mem->_trails[1].level  = _ceu_level;
    _ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Init_Code_USART_Init__TERM_63;

    tceu_evt   __ceu_evt   = { CEU_INPUT__CODE_TERMINATED, {_ceu_mem} };
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;

/* Code_Finalize (n=838, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
_ceu_nxt->params_n = 0;

/* Code_Finalize (n=838, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

#ifdef CEU_FEATURES_POOL
if (_ceu_mem->pak != NULL) {
    tceu_code_mem_dyn* __ceu_dyn =
        (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));
    __ceu_dyn->is_alive = 0;
}
#endif

ceu_stack_clear(_ceu_cur, _ceu_mem);

if (_ceu_mem->has_term) {
    _ceu_mem->has_term = 0;
    return 1;
} else {
    return 0;
}

/* Code_Finalize (n=838, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Block (n=840, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=1105, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=1105, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=1186, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_47);

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_2_IN_46:;

/* Block (n=836, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=834, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=176, ln=67) */

#line 67 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=168, ln=67) */

#line 67 "./libraries/driver-usart/avr/usart.ceu"

        UCSR0A = 1 << U2X0;
        UBRR0H = (USART_BAUD((((*((tceu_code_mem_USART_Init*)_ceu_mem)).bps)))>>8); // set baud rate
        UBRR0L = (USART_BAUD((((*((tceu_code_mem_USART_Init*)_ceu_mem)).bps))));
        UCSR0C = (1<<USBS0) | (3<<UCSZ00); // 8data, 2stop-bit
        UCSR0B = (1<<RXEN0) | (1<<RXCIE0); // enables RX & ISRS
    
/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_USART_Init_Par_Or_sub_2_IN_52;

/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or_sub_1_IN_51);

/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_1_IN_51:;

/* Finalize_Case (n=1107, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_USART_Init_Finalize_Case__IN_56;

/* Finalize_Case (n=1107, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=1107, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Finalize_Case__IN_56:;

/* Block (n=171, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=169, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"

            UCSR0B = 0; // disables TX/RX & ISRS
        
/* Block (n=171, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=1107, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=1107, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=1192, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_53);

/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_2_IN_52:;

/* Await_Forever (n=174, ln=79) */

#line 79 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Nat_Stmt (n=997, ln=67) */

#line 67 "./libraries/driver-usart/avr/usart.ceu"
ceu_assert(0, "reached end of `code`");
/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_53);

/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__OUT_53:;

/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Init_Par_Or__CLR_54;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 2+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1195, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__CLR_54:;

/* Block (n=176, ln=67) */

#line 67 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=834, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=836, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

/* Do (n=837, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Do__OUT_60:;

/* Do (n=837, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
    _ceu_mem->has_term = 1;

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_47);

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__OUT_47:;

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_USART_Init_Par_Or__CLR_48;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1189, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__CLR_48:;

/* Block (n=845, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=846, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Code (n=846, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_Par_Or_sub_2_IN_65;

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or_sub_1_IN_64);

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or_sub_1_IN_64:;

/* Abs_Spawn (n=335, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__PROPAGATE_CODE;

/* Abs_Spawn (n=335, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[1].evt.mem = (tceu_code_mem*) &(CEU_APP.root.__mem_335);

/* Abs_Spawn (n=335, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[1].lbl = CEU_LABEL_Await_Spawn__OUT_68;

/* Abs_Spawn (n=335, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{
    *((tceu_code_mem_USART_Init*)(&(CEU_APP.root. __mem_335))) = 
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_USART_Init __ceu_334;__ceu_334.bps = 9600;; __ceu_334;})

#else
(tceu_code_mem_USART_Init) { .bps = 9600 }

#endif
;
#ifdef CEU_FEATURES_POOL
    (&(CEU_APP.root. __mem_335))->_mem.pak    = NULL;
#endif
    (&(CEU_APP.root. __mem_335))->_mem.up_mem = _ceu_mem;
    (&(CEU_APP.root. __mem_335))->_mem.depth  = 0;
    (&(CEU_APP.root. __mem_335))->_mem.has_term = 0;
    (&(CEU_APP.root. __mem_335))->_mem.trails_n = 5;
    memset(&(&(CEU_APP.root. __mem_335))->_mem._trails, 0, 5*sizeof(tceu_trl));
    (&(CEU_APP.root. __mem_335))->_mem._trails[0].evt.id = CEU_INPUT__STACKED;
    (&(CEU_APP.root. __mem_335))->_mem._trails[0].level  = _ceu_level+1;
    (&(CEU_APP.root. __mem_335))->_mem._trails[0].lbl    = CEU_CODE_USART_Init_to_lbl((&(CEU_APP.root. __mem_335)));
}

{
    tceu_evt   __ceu_evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range __ceu_range = { (tceu_code_mem*)(&(CEU_APP.root. __mem_335)), 0, 5-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    //return 1; (later, after deciding for spawn/await)
}

/* Abs_Spawn (n=335, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 1;

/* Abs_Spawn (n=335, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Await_Spawn__OUT_68:;

/* Await_Forever (n=1198, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 0;

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_66);

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or_sub_2_IN_65:;

/* Vec_Init (n=1063, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_vector_init(&((CEU_APP.root.str_346)),20, 0, 0, sizeof(byte),
                (byte*)&((CEU_APP.root.str_346_buf)));

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    ceu_vector_setlen(&((CEU_APP.root.str_346)), 0, 0);
    __ceu_nxt = 0;

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    ceu_vector_setlen(&((CEU_APP.root.str_346)), (((CEU_APP.root.str_346)).len + 3), 1);

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    *((byte*)
        ceu_vector_buf_get(&((CEU_APP.root.str_346)), __ceu_nxt++)) = 0;

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    *((byte*)
        ceu_vector_buf_get(&((CEU_APP.root.str_346)), __ceu_nxt++)) = 0;

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    *((byte*)
        ceu_vector_buf_get(&((CEU_APP.root.str_346)), __ceu_nxt++)) = 0;

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"

/* Set_Vec (n=345, ln=7) */

#line 7 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Loop (n=427, ln=12) */

#line 12 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
while (1) {
        
/* Block (n=426, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Block (n=952, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
(CEU_APP.root.__lim_950) = 15 + (1*0*-1);

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_assert(1> 0, "invalid `loop` step : expected positive number");

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
(CEU_APP.root.__fr_950) = 1;
((CEU_APP.root.i)) = 1 + 1 * 0;
ceu_assert_ex(((CEU_APP.root.i))>=(int)(CEU_APP.root.__fr_950),
    "control variable overflow", CEU_TRACE(-3));
while (1) {

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    if (((CEU_APP.root.i)) > (CEU_APP.root.__lim_950)) {
        break;
    }

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
        
/* Block (n=386, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[6].level  = _ceu_level;
_ceu_mem->_trails[6].lbl    = CEU_LABEL_Par_Or_sub_2_IN_70;

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or_sub_1_IN_69);

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or_sub_1_IN_69:;

/* Block (n=361, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Await_Wclock (n=359, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_wclock(50000.0, &(CEU_APP.root.__wclk_359), NULL, CEU_TRACE(0));

_CEU_HALT_359_:

/* Await_Wclock (n=359, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[5].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=359, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[5].lbl = CEU_LABEL_Await_Wclock__OUT_73;

/* Await_Wclock (n=359, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 0;

/* Await_Wclock (n=359, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Await_Wclock__OUT_73:;

/* Await_Wclock (n=359, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &(CEU_APP.root.__wclk_359), CEU_TRACE(0)) ) {
        goto _CEU_HALT_359_;
    }
}

/* Block (n=361, ln=19) */

#line 19 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_71);

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or_sub_2_IN_70:;

/* Block (n=383, ln=21) */

#line 21 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Loop (n=381, ln=21) */

#line 21 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
while (1) {
        
/* Block (n=380, ln=22) */

#line 22 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Emit_Ext_emit (n=366, ln=22) */

#line 22 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Emit_Ext_emit (n=366, ln=22) */

#line 22 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=366, ln=22) */

#line 22 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
__ceu_ps._1 = 1;

/* Emit_Ext_emit (n=366, ln=22) */

#line 22 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=366, ln=22) */

#line 22 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Await_Wclock (n=369, ln=23) */

#line 23 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_wclock(1000.0, &(CEU_APP.root.__wclk_369), NULL, CEU_TRACE(0));

_CEU_HALT_369_:

/* Await_Wclock (n=369, ln=23) */

#line 23 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=369, ln=23) */

#line 23 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].lbl = CEU_LABEL_Await_Wclock__OUT_76;

/* Await_Wclock (n=369, ln=23) */

#line 23 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 0;

/* Await_Wclock (n=369, ln=23) */

#line 23 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Await_Wclock__OUT_76:;

/* Await_Wclock (n=369, ln=23) */

#line 23 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &(CEU_APP.root.__wclk_369), CEU_TRACE(0)) ) {
        goto _CEU_HALT_369_;
    }
}

/* Emit_Ext_emit (n=374, ln=24) */

#line 24 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Emit_Ext_emit (n=374, ln=24) */

#line 24 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=374, ln=24) */

#line 24 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
__ceu_ps._1 = 0;

/* Emit_Ext_emit (n=374, ln=24) */

#line 24 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=374, ln=24) */

#line 24 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Await_Wclock (n=378, ln=25) */

#line 25 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_wclock((((CEU_APP.root.i)))*1000.0, &(CEU_APP.root.__wclk_378), NULL, CEU_TRACE(0));

_CEU_HALT_378_:

/* Await_Wclock (n=378, ln=25) */

#line 25 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=378, ln=25) */

#line 25 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].lbl = CEU_LABEL_Await_Wclock__OUT_78;

/* Await_Wclock (n=378, ln=25) */

#line 25 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 0;

/* Await_Wclock (n=378, ln=25) */

#line 25 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Await_Wclock__OUT_78:;

/* Await_Wclock (n=378, ln=25) */

#line 25 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &(CEU_APP.root.__wclk_378), CEU_TRACE(0)) ) {
        goto _CEU_HALT_378_;
    }
}

/* Block (n=380, ln=22) */

#line 22 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Loop (n=381, ln=21) */

#line 21 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_81:;

/* Loop (n=381, ln=21) */

#line 21 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
        *_ceu_trlK = 5;
}

/* Loop (n=381, ln=21) */

#line 21 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Break__OUT_83:;

/* Block (n=383, ln=21) */

#line 21 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_71);

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or__OUT_71:;

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_Par_Or__CLR_72;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 4+1, 6 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=384, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or__CLR_72:;

/* Block (n=386, ln=18) */

#line 18 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_87:;

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    ((CEU_APP.root.i)) = ((CEU_APP.root.i)) + 1;
    ceu_assert_ex(((CEU_APP.root.i))>(int)(CEU_APP.root.__fr_950),
        "control variable overflow", CEU_TRACE(-2));
        *_ceu_trlK = 2;
}

/* Loop_Num (n=950, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Break__OUT_89:;

/* Block (n=952, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Block (n=960, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
(CEU_APP.root.__lim_958) = 14 + (1*0*-1);

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_assert(1> 0, "invalid `loop` step : expected positive number");

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
(CEU_APP.root.__fr_958) = 2;
((CEU_APP.root.i)) = 2 + 1 * 0;
ceu_assert_ex(((CEU_APP.root.i))>=(int)(CEU_APP.root.__fr_958),
    "control variable overflow", CEU_TRACE(-3));
while (1) {

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    if (((CEU_APP.root.i)) > (CEU_APP.root.__lim_958)) {
        break;
    }

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
        
/* Block (n=423, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[6].level  = _ceu_level;
_ceu_mem->_trails[6].lbl    = CEU_LABEL_Par_Or_sub_2_IN_92;

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or_sub_1_IN_91);

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or_sub_1_IN_91:;

/* Block (n=396, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Await_Wclock (n=394, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_wclock(50000.0, &(CEU_APP.root.__wclk_394), NULL, CEU_TRACE(0));

_CEU_HALT_394_:

/* Await_Wclock (n=394, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[5].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=394, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[5].lbl = CEU_LABEL_Await_Wclock__OUT_95;

/* Await_Wclock (n=394, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 0;

/* Await_Wclock (n=394, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Await_Wclock__OUT_95:;

/* Await_Wclock (n=394, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &(CEU_APP.root.__wclk_394), CEU_TRACE(0)) ) {
        goto _CEU_HALT_394_;
    }
}

/* Block (n=396, ln=32) */

#line 32 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_93);

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or_sub_2_IN_92:;

/* Block (n=420, ln=34) */

#line 34 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Loop (n=418, ln=34) */

#line 34 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
while (1) {
        
/* Block (n=417, ln=35) */

#line 35 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Emit_Ext_emit (n=401, ln=35) */

#line 35 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Emit_Ext_emit (n=401, ln=35) */

#line 35 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=401, ln=35) */

#line 35 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
__ceu_ps._1 = 1;

/* Emit_Ext_emit (n=401, ln=35) */

#line 35 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=401, ln=35) */

#line 35 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Await_Wclock (n=404, ln=36) */

#line 36 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_wclock(1000.0, &(CEU_APP.root.__wclk_404), NULL, CEU_TRACE(0));

_CEU_HALT_404_:

/* Await_Wclock (n=404, ln=36) */

#line 36 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=404, ln=36) */

#line 36 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].lbl = CEU_LABEL_Await_Wclock__OUT_98;

/* Await_Wclock (n=404, ln=36) */

#line 36 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 0;

/* Await_Wclock (n=404, ln=36) */

#line 36 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Await_Wclock__OUT_98:;

/* Await_Wclock (n=404, ln=36) */

#line 36 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &(CEU_APP.root.__wclk_404), CEU_TRACE(0)) ) {
        goto _CEU_HALT_404_;
    }
}

/* Emit_Ext_emit (n=409, ln=37) */

#line 37 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
{

/* Emit_Ext_emit (n=409, ln=37) */

#line 37 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=409, ln=37) */

#line 37 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
__ceu_ps._1 = 0;

/* Emit_Ext_emit (n=409, ln=37) */

#line 37 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=409, ln=37) */

#line 37 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Await_Wclock (n=415, ln=38) */

#line 38 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_wclock(((16-((CEU_APP.root.i))))*1000.0, &(CEU_APP.root.__wclk_415), NULL, CEU_TRACE(0));

_CEU_HALT_415_:

/* Await_Wclock (n=415, ln=38) */

#line 38 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=415, ln=38) */

#line 38 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[6].lbl = CEU_LABEL_Await_Wclock__OUT_100;

/* Await_Wclock (n=415, ln=38) */

#line 38 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
return 0;

/* Await_Wclock (n=415, ln=38) */

#line 38 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Await_Wclock__OUT_100:;

/* Await_Wclock (n=415, ln=38) */

#line 38 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &(CEU_APP.root.__wclk_415), CEU_TRACE(0)) ) {
        goto _CEU_HALT_415_;
    }
}

/* Block (n=417, ln=35) */

#line 35 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Loop (n=418, ln=34) */

#line 34 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_103:;

/* Loop (n=418, ln=34) */

#line 34 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
        *_ceu_trlK = 5;
}

/* Loop (n=418, ln=34) */

#line 34 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Break__OUT_105:;

/* Block (n=420, ln=34) */

#line 34 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_93);

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or__OUT_93:;

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_Par_Or__CLR_94;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 4+1, 6 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=421, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or__CLR_94:;

/* Block (n=423, ln=31) */

#line 31 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_109:;

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
    ((CEU_APP.root.i)) = ((CEU_APP.root.i)) + 1;
    ceu_assert_ex(((CEU_APP.root.i))>(int)(CEU_APP.root.__fr_958),
        "control variable overflow", CEU_TRACE(-2));
        *_ceu_trlK = 2;
}

/* Loop_Num (n=958, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Break__OUT_111:;

/* Block (n=960, ln=30) */

#line 30 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Block (n=426, ln=13) */

#line 13 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Loop (n=427, ln=12) */

#line 12 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_115:;

/* Loop (n=427, ln=12) */

#line 12 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
        *_ceu_trlK = 1;
}

/* Loop (n=427, ln=12) */

#line 12 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Loop_Break__OUT_117:;

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_66);

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or__OUT_66:;

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_Par_Or__CLR_67;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 6 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1201, ln=5) */

#line 5 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Par_Or__CLR_67:;

/* Block (n=466, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

/* Do (n=467, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=467, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
case CEU_LABEL_Do__OUT_119:;

/* Block (n=471, ln=1) */

#line 1 "/home/maged/Desktop/ceu-maker/ceu-maker/ceu-maker-ubuntu/examples/ceu-arduino/blink-01/blink-01.ceu"
}

    }
    //ceu_assert(0, "unreachable code");
    return 0;
#undef CEU_TRACE
}

#if defined(_CEU_DEBUG)
#define _CEU_DEBUG
static int xxx = 0;
#endif

static void ceu_bcast_mark (tceu_nstk level, tceu_stk* cur)
{
    tceu_ntrl trlK = cur->range.trl0;

    for (; trlK<=cur->range.trlF; trlK++)
    {
        tceu_trl* trl = &cur->range.mem->_trails[trlK];

        //printf(">>> mark [%d/%p] evt=%d\n", trlK, trl, trl->evt.id);
#ifdef CEU_TESTS
        _ceu_tests_trails_visited_++;
#endif
        switch (trl->evt.id)
        {
#ifdef CEU_FEATURES_POOL
            case CEU_INPUT__PROPAGATE_POOL: {
                tceu_code_mem_dyn* v = trl->evt.pak->first.nxt;
                while (v != &trl->evt.pak->first) {
                    tceu_range range_ = { &v->mem[0],
                                          0, (tceu_ntrl)((&v->mem[0])->trails_n-1) };
                    tceu_stk cur_ = *cur;
                    cur_.range = range_;
                    ceu_bcast_mark(level, &cur_);
                    v = v->nxt;
                }
                break;
            }
#endif

#ifdef CEU_FEATURES_PAUSE
            case CEU_INPUT__PAUSE_BLOCK: {
                u8 was_paused = trl->pse_paused;
                if ( (cur->evt.id == trl->pse_evt.id)                               &&
                     (cur->evt.id<CEU_EVENT__MIN || cur->evt.mem==trl->pse_evt.mem) &&
                     (*((u8*)cur->params) != trl->pse_paused) )
                {
                    trl->pse_paused = *((u8*)cur->params);

                    tceu_evt evt_;
                    tceu_range range_ = { cur->range.mem,
                                          (tceu_ntrl)(trlK+1), (tceu_ntrl)(trlK+trl->pse_skip) };
                    if (trl->pse_paused) {
                        evt_.id = CEU_INPUT__PAUSE;
                    } else {
                        CEU_APP.wclk_min_set = 0;   /* maybe resuming a timer, let it be the minimum set */
                        evt_.id = CEU_INPUT__RESUME;
                    }
                    tceu_stk cur_ = { evt_, range_, NULL, 0 };
                    ceu_bcast_mark(level, &cur_);
                }
                /* don't skip if pausing now */
                if (was_paused && cur->evt.id!=CEU_INPUT__CLEAR) {
                                  /* also don't skip on CLEAR (going reverse) */
                    trlK += trl->pse_skip;
                }
                break;
            }
#endif

            case CEU_INPUT__PROPAGATE_CODE: {
#if 0
                // TODO: simple optimization that could be done
                //          - do it also for POOL?
                if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && occ->params==trl->evt.mem ) {
                    // dont propagate when I am terminating
                } else
#endif
                tceu_range range_ = {
                    (tceu_code_mem*)trl->evt.mem,
                    0,
                    (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1)
                };
                tceu_stk cur_ = *cur;
                cur_.range = range_;
                ceu_bcast_mark(level, &cur_);
                //break;    (may awake from CODE_TERMINATED)
            }

            default: {
                if (cur->evt.id == CEU_INPUT__CLEAR) {
                    if (trl->evt.id == CEU_INPUT__FINALIZE) {
//printf("AWK %d %d\n", trlK, trl->lbl);
                        goto _CEU_AWAKE_YES_;
                    }
                } else if (cur->evt.id==CEU_INPUT__CODE_TERMINATED && trl->evt.id==CEU_INPUT__PROPAGATE_CODE) {
//printf("TERM %d %d\n", trlK, trl->lbl);
                    if (trl->evt.mem == cur->evt.mem) {
                        goto _CEU_AWAKE_YES_;
                    }
                } else if (trl->evt.id == cur->evt.id) {
#ifdef CEU_FEATURES_PAUSE
                    if (cur->evt.id==CEU_INPUT__PAUSE || cur->evt.id==CEU_INPUT__RESUME) {
                        goto _CEU_AWAKE_YES_;
                    }
#endif
                    if (trl->evt.id>CEU_EVENT__MIN || trl->evt.id==CEU_INPUT__CODE_TERMINATED) {
                        if (trl->evt.mem == cur->evt.mem) {
                            goto _CEU_AWAKE_YES_;   /* internal event matches "mem" */
                        }
                    } else {
                        if (cur->evt.id != CEU_INPUT__NONE) {
                            goto _CEU_AWAKE_YES_;       /* external event matches */
                        }
                    }
                }

                continue;

_CEU_AWAKE_YES_:
                trl->evt.id = CEU_INPUT__STACKED;
                trl->level  = level;
            }
        }
    }
}

static int ceu_bcast_exec (tceu_nstk level, tceu_stk* cur, tceu_stk* nxt)
{
    /* CLEAR: inverse execution order */
    tceu_ntrl trl0 = cur->range.trl0;
    tceu_ntrl trlF = cur->range.trlF;
    if (trl0 > trlF) {
        return 0;
    }
    if (cur->evt.id == CEU_INPUT__CLEAR) {
        tceu_ntrl tmp = trl0;
        trl0 = trlF;
        trlF = tmp;
    }

    tceu_ntrl trlK = trl0;

    //printf(">>> exec %d -> %d\n", trl0, trlF);
    while (1)
    {
        tceu_trl* trl = &cur->range.mem->_trails[trlK];

        //printf(">>> exec [%d/%p] evt=%d\n", trlK, trl, trl->evt.id);
        switch (trl->evt.id)
        {
            case CEU_INPUT__PROPAGATE_CODE: {
#if 0
                // TODO: simple optimization that could be done
                //          - do it also for POOL?
                if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && occ->params==trl->evt.mem ) {
                    // dont propagate when I am terminating
                } else
#endif
                {
                    tceu_range range_ = {
                        (tceu_code_mem*)trl->evt.mem,
                        0,
                        (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1)
                    };
                    tceu_stk cur_ = *cur;
                    cur_.range = range_;
                    if (ceu_bcast_exec(level, &cur_, nxt)) {
                        return 1;
                    }
                }
                break;
            }

#ifdef CEU_FEATURES_POOL
            case CEU_INPUT__PROPAGATE_POOL: {
                ceu_assert_ex(trl->evt.pak->n_traversing < 255, "bug found", CEU_TRACE_null);
                trl->evt.pak->n_traversing++;
                tceu_code_mem_dyn* v = trl->evt.pak->first.nxt;
                while (v != &trl->evt.pak->first) {
                    if (v->is_alive) {
                        tceu_range range_ = { &v->mem[0],
                                              0, (tceu_ntrl)((&v->mem[0])->trails_n-1) };
                        tceu_stk cur_ = *cur;
                        cur_.range = range_;
                        if (ceu_bcast_exec(level, &cur_, nxt)) {
                            trl->evt.pak->n_traversing--;
                            return 1;
                        }
                    }
                    v = v->nxt;
                }
                trl->evt.pak->n_traversing--;
                ceu_code_mem_dyn_gc(trl->evt.pak);
                break;
            }
#endif

            case CEU_INPUT__STACKED: {
                if (trl->evt.id==CEU_INPUT__STACKED && trl->level==level) {
                    trl->evt.id = CEU_INPUT__NONE;
//printf("STK = %d\n", trlK);
                    if (ceu_lbl(level, cur, nxt, cur->range.mem, trl->lbl, &trlK)) {
                        return 1;
                    }
//printf("<<< trlK = %d\n", trlK);
                }
                break;
            }
        }

        if (cur->evt.id == CEU_INPUT__CLEAR) {
            trl->evt.id = CEU_INPUT__NONE;
        }

        if (trlK == trlF) {
            break;
        } else if (cur->evt.id == CEU_INPUT__CLEAR) {
            trlK--; trl--;
        } else {
            trlK++; trl++;
        }
    }
    return 0;
}

static void ceu_bcast (tceu_nstk level, tceu_stk* cur)
{
    if (cur->evt.id>CEU_INPUT__PRIM && cur->evt.id<CEU_EVENT__MIN) {
        switch (cur->evt.id) {
            case CEU_INPUT__WCLOCK:
                CEU_APP.wclk_min_cmp = CEU_APP.wclk_min_set;    /* swap "cmp" to last "set" */
                CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;     /* new "set" resets to inactive */
                ceu_callback_wclock_min(CEU_WCLOCK_INACTIVE, CEU_TRACE_null);
                if (CEU_APP.wclk_min_cmp <= *((s32*)cur->params)) {
                    CEU_APP.wclk_late = *((s32*)cur->params) - CEU_APP.wclk_min_cmp;
                }
                break;
#ifdef CEU_FEATURES_ASYNC
            case CEU_INPUT__ASYNC:
                CEU_APP.async_pending = 0;
                break;
#endif
        }
        if (cur->evt.id != CEU_INPUT__WCLOCK) {
            CEU_APP.wclk_late = 0;
        }
    }

    //printf(">>> BCAST[%d]: %d\n", cur->evt.id, level);
    ceu_bcast_mark(level, cur);
    while (1) {
        tceu_stk nxt;
        nxt.is_alive = 1;
        nxt.prv = cur;
        int ret = ceu_bcast_exec(level, cur, &nxt);
        if (ret) {
            ceu_assert_sys(level < 255, "too many stack levels");
            ceu_bcast(level+1, &nxt);
            if (!cur->is_alive) {
                break;
            }
        } else {
            break;
        }
    }

    CEU_APP.stack_i -= cur->params_n;
    //printf("<<< BCAST: %d\n", level);
}

CEU_API void ceu_input (tceu_nevt id, void* params)
{
    s32 dt = ceu_callback_wclock_dt(CEU_TRACE_null);
    if (dt != CEU_WCLOCK_INACTIVE) {
        tceu_evt   evt   = {CEU_INPUT__WCLOCK, {NULL}};
        tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
        tceu_stk   cur   = { evt, range, &dt, 0, 1, NULL };
        ceu_bcast(1, &cur);
    }
    if (id != CEU_INPUT__NONE) {
        tceu_evt   evt   = {id, {NULL}};
        tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
        tceu_stk   cur   = { evt, range, params, 0, 1, NULL };
        ceu_bcast(1, &cur);
    }
}

CEU_API void ceu_start (int argc, char* argv[]) {
#ifdef CEU_FEATURES_OS
    CEU_APP.argc     = argc;
    CEU_APP.argv     = argv;
    CEU_APP.end_ok   = 0;
#endif

#ifdef CEU_FEATURES_ASYNC
    CEU_APP.async_pending = 0;
#endif

    CEU_APP.wclk_late = 0;
    CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;
    CEU_APP.wclk_min_cmp = CEU_WCLOCK_INACTIVE;

    CEU_APP.root._mem.up_mem   = NULL;
    CEU_APP.root._mem.depth    = 0;

#ifdef CEU_FEATURES_TRACE
    CEU_APP.root._mem.trace.up = NULL;
#endif
#ifdef CEU_FEATURES_EXCEPTION
    CEU_APP.root._mem.catches  = NULL;
#endif
#ifdef CEU_FEATURES_LUA
    CEU_APP.root._mem.lua      = NULL;
#endif

#ifdef CEU_FEATURES_THREAD
    pthread_mutex_init(&CEU_APP.threads_mutex, NULL);
    CEU_APP.threads_head = NULL;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
#endif

    CEU_APP.stack_i = 0;

    CEU_APP.root._mem.trails_n = CEU_TRAILS_N;
    memset(&CEU_APP.root._trails, 0, CEU_TRAILS_N*sizeof(tceu_trl));
    CEU_APP.root._trails[0].evt.id = CEU_INPUT__STACKED;
    CEU_APP.root._trails[0].level  = 1;
    CEU_APP.root._trails[0].lbl    = CEU_LABEL_ROOT;

    ceu_callback_start(CEU_TRACE_null);

    tceu_evt   evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
    tceu_stk   cur   = { evt, range, NULL, 0, 1, NULL };
    ceu_bcast(1, &cur);
}
CEU_API void ceu_stop (void) {
#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    ceu_assert_ex(ceu_threads_gc(1) == 0, "bug found", CEU_TRACE_null); /* wait all terminate/free */
#endif
    ceu_callback_stop(CEU_TRACE_null);
}

/*****************************************************************************/

CEU_API int ceu_loop (int argc, char* argv[])
{
    ceu_start(argc, argv);

#ifdef CEU_FEATURES_OS
    while (!CEU_APP.end_ok)
#else
    while (1)
#endif
    {
        ceu_callback_step(CEU_TRACE_null);
#ifdef CEU_FEATURES_THREAD
        if (CEU_APP.threads_head != NULL) {
            CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
/* TODO: remove this!!! */
            CEU_THREADS_SLEEP(100); /* allow threads to do "atomic" and "terminate" */
            CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
            ceu_threads_gc(0);
        }
#endif
#ifdef CEU_FEATURES_ASYNC
        ceu_input(CEU_INPUT__ASYNC, NULL);
#endif
    }

#ifdef CEU_FEATURES_OS
    ceu_stop();

#ifdef CEU_TESTS
    printf("_ceu_tests_bcasts_ = %d\n", _ceu_tests_bcasts_);
    printf("_ceu_tests_trails_visited_ = %d\n", _ceu_tests_trails_visited_);
    fflush(stdout);
#endif

    return CEU_APP.end_val;
#else
    return 0;
#endif
}
